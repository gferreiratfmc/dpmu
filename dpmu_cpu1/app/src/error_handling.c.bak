/*
 * error_codes.c
 *
 *  Created on: 15 aug. 2023
 *      Author: Henrik Borg henrik.borg@ekpower.se hb
 */

#include <error_handling.h>
#include <stdbool.h>

#include "canopen_emcy.h"
#include "cli_cpu1.h"
#include "common.h"
#include "convert.h"
#include "gen_indices.h"
#include "hal.h"
#include "shared_variables.h"
#include "state.h"
#include "temperature_sensor.h"
#include "timer.h"
#include "usr_401.h"

enum short_circuit_states{
    no_short_circuit = 0,
    shared_bus_disconnected,
    reconnect_shared_bus,
    shared_bus_reconnected,
    shared_bus_not_reconnected,
    clear_error,
    wait_for_error_to_disappear,
};

       uint32_t global_error_code         = 0;
static uint32_t global_error_code_handled = 0;
static uint32_t global_error_code_sent    = 0;

/* brief: check if DC bus Voltage level is above max
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_dcbus_over_voltage(void)
{
    static bool timer_started = false;
    static uint32_t time_start;

    if(global_error_code & (1UL << ERROR_BUS_OVER_VOLTAGE))
    {
        if(!(global_error_code_handled & (1UL << ERROR_BUS_OVER_VOLTAGE)))
        {
            if(!timer_started)
            {
                time_start = timer_get_ticks() & 0x7fffffff;
                timer_started = true;
            }

            /* ms ticks, enough with 127 ms */
            uint32_t elapsed_time = (timer_get_ticks() & 0x7fffffff) - time_start;
            //TODO - Timer does not handle wrap around

            /* send EMCY - send it once */
            if(!(global_error_code_sent & (1UL << ERROR_BUS_OVER_VOLTAGE)))
            {
                /* disconnect load */
                cli_switches(IPC_SWITCHES_QLB, SW_OFF);

                canopen_emcy_send_dcbus_over_voltage(1);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_BUS_OVER_VOLTAGE);
            }

            //TODO what shall the timeout be? in milliseconds
            /* check timeout */
            if(2 < elapsed_time)
            {
                /* disconnect all switches
                 * turn off regulation */
                IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_BUS_OVER_VOLTAGE);
            }
        } else
        {
            ;
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_BUS_OVER_VOLTAGE))
            canopen_emcy_send_dcbus_over_voltage(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_BUS_OVER_VOLTAGE);
        global_error_code_handled &= ~(1UL << ERROR_BUS_OVER_VOLTAGE);

        /* clear the timer */
        timer_started = false;
    }
}

/* brief: check if DC bus Voltage level is below min
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_dcbus_under_voltage(void)
{
    static bool timer_started = false;
    static uint32_t time_start;

    if(global_error_code & (1UL << ERROR_BUS_UNDER_VOLTAGE))
    {
        if(!(global_error_code_handled & (1UL << ERROR_BUS_UNDER_VOLTAGE)))
        {
            if(!timer_started)
            {
                time_start = timer_get_ticks() & 0x7fffffff;
                timer_started = true;
            }

            /* ms ticks, enough with 127 ms */
            int16_t elapsed_time = (timer_get_ticks() & 0x7fff) - time_start;
            //TODO - Time does not handle wrap around

            /* send EMCY - send it once */
            if(!(global_error_code_sent & (1UL << ERROR_BUS_UNDER_VOLTAGE)))
            {
                canopen_emcy_send_dcbus_under_voltage(1);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_BUS_UNDER_VOLTAGE);
            }

            /* check timeout */
            if(2 < elapsed_time)
            {
                /* disconnect all switches
                 * turn off regulation */
                IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_BUS_UNDER_VOLTAGE);
            }
        } else
        {
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {   /* problem resolved */
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_BUS_UNDER_VOLTAGE))
            canopen_emcy_send_dcbus_under_voltage(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_BUS_UNDER_VOLTAGE);
        global_error_code_handled &= ~(1UL << ERROR_BUS_UNDER_VOLTAGE);

        /* clear the timer */
        timer_started = false;
    }
}

/* return: reading of error flag as true/false */
static inline bool short_circuit_flag_set(void)
{
    return (global_error_code & (1UL << ERROR_BUS_SHORT_CIRCUIT)? true : false);
}

/* brief: disconnects the other DPMU from the shared bus
 *
 * details: waits for answer
 *
 * requirements:
 *
 * argument: none
 *
 * return: true  - the other DPMU answer it has disconnected
 *         false - the other DPMU answer it has not disconnected,
 *                 or no answer
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static bool disconnect_other_dpmu_from_shared_bus(void)
{
    bool ret;
    int answer;
    uint32_t time_start = timer_get_ticks() & 0x7fffffff;
    int16_t elapsed_time;

    //TODO send IPC to CPU2 that informs other DPMUs over CANB

    /* check answer
     * non-blocking
     * */
    while(1)
    {
        /* retrieve answer from CPU2 */
        //TODO implement this function, change to a good name
//        answer = disconnect_other_dpmu_from_shared_bus_answer();

        /* check if we got answer
         * -1 -> no answer
         */
        if(-1 != answer)
        {
            ret = (0 == answer ? false : true);
            //TODO send EMCY CANB communication error to IOP?
            break;
        }

        /* check timer */
        elapsed_time = (timer_get_ticks() & 0x7fff) - time_start;
        if(2 < elapsed_time)
        {
            ret = false;
            break;
        }
    }

    return ret;
}

/* brief: check if DC bus Voltage level is below short circuit detection level
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *          tries to reconnect the DPMUs through shared bus
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_dcbus_short_circuit(void)
{
    static bool timer_started = false;
    static uint32_t time_start;
    int16_t elapsed_time;

    uint8_t state = no_short_circuit;

    switch(state)
    {
    case no_short_circuit:
        if(short_circuit_flag_set())
        {
            if(!(global_error_code_handled & (1UL << ERROR_BUS_SHORT_CIRCUIT)))
            {
                /* Turn OFF QSHARE (GLOAD_3) */
                cli_switches(IPC_SWITCHES_QSB, SW_OFF);

                /* check if correct DPMU type to use shared bus */
                if(!allowed_to_use_shared_bus())
                {
                    /* if we are not allowed to use the shared bus and get a
                     * short circuit, there will be no reasons to check for
                     * short circuit after disconnecting from something we are
                     * not connected to
                     *
                     * meaning: full scale problem, emergency shutdown
                     */

                    /* disconnect all switches
                     * turn off regulation */
                    IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                    /* send EMCY - send it once */
                    if(!(global_error_code_sent & (1UL << ERROR_BUS_SHORT_CIRCUIT)))
                    {
                        canopen_emcy_send_dcbus_short_curcuit(1);

                        /* mark it sent */
                        global_error_code_sent |= (1UL << ERROR_BUS_SHORT_CIRCUIT);
                    }

                    /* mark handled */
                    global_error_code_handled |= (1UL << ERROR_BUS_SHORT_CIRCUIT);

                    /* next state -> shared bus disconnected */
                    state = wait_for_error_to_disappear;

                    break;
                }

                /* send EMCY - send it once */
                if(!(global_error_code_sent & (1UL << ERROR_BUS_SHORT_CIRCUIT)))
                {
                    canopen_emcy_send_dcbus_short_curcuit(1);

                    /* mark it sent */
                    global_error_code_sent |= (1UL << ERROR_BUS_SHORT_CIRCUIT);
                }

                /* disconnect the other/others DPMU/s, Qsb */
                if(!disconnect_other_dpmu_from_shared_bus())
                {   /* the other DPMU did not answer our request */

                    //TODO delay needed between the two EMCY messages?

                    /* send EMCY - send it once */
                    canopen_emcy_send_power_sharing_error(1);

                    /* mark handled */
                    global_error_code_handled |= (1UL << ERROR_BUS_SHORT_CIRCUIT);

                    /* next state -> shared bus disconnected */
                    state = wait_for_error_to_disappear;

                    break;
                } else
                {
                    //TODO Mark as for continuing with reduced effect
                    //     Probably as signal to CPU2 to change some parameter
//                    sharedVars_cpu1toCpu2.available_power_budget_dc_input = xxx;

                    /* next state -> shared bus disconnected */
                    state = shared_bus_disconnected;
                }
            }
        } else
        {
            /* send EMCY CLEAR - send it once */
            if(global_error_code_sent & (1UL << ERROR_BUS_SHORT_CIRCUIT))
                canopen_emcy_send_dcbus_short_curcuit(0);

            /* mark as unhandled - nothing need to be done  */
            global_error_code_sent    &= ~(1UL << ERROR_BUS_SHORT_CIRCUIT);
            global_error_code_handled &= ~(1UL << ERROR_BUS_SHORT_CIRCUIT);
        }
        break;
    case shared_bus_disconnected:
        if(!timer_started)
        {
            time_start = timer_get_ticks() & 0x7fffffff;
            timer_started = true;
        }

        /* wait and see if error disappears */
        if(short_circuit_flag_set())
        {
            /* ms ticks, enough with 127 ms */
            elapsed_time = (timer_get_ticks() & 0x7fff) - time_start;
            //TODO - Time does not handle wrap around

            /* check timeout */
            if(2 < elapsed_time)
            {   /* error persist */
                /* disconnect all switches
                 * turn off regulation */
                IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_BUS_SHORT_CIRCUIT);

                /* next state -> wait for error to disappear */
                state = wait_for_error_to_disappear;
            }
        } else
        {   /* disconnecting from shared bus solves the problem */

            /* next state -> reconnect shared bus */
            state = reconnect_shared_bus;
        }
        break;
    case reconnect_shared_bus:
        /* clear the timer */
        timer_started = false;

        if(short_circuit_flag_set())
        {   /* error persist
             * returned during switching to this state
             * error came back after disconnecting shared bus
             * very unlikely to reach this if-statement
             * */

            /* disconnect all switches
             * turn off regulation */
            IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

            /* send EMCY - send it once */
            if(!(global_error_code_sent & (1UL << ERROR_BUS_SHORT_CIRCUIT)))
            {
                canopen_emcy_send_dcbus_short_curcuit(1);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_BUS_SHORT_CIRCUIT);
            }

            /* mark handled */
            global_error_code_handled |= (1UL << ERROR_BUS_SHORT_CIRCUIT);

            /* next state -> shared bus not reconnected */
            state = wait_for_error_to_disappear;
        } else
        {
            bool ret;
            /* try to connect the shared bus on both devices
             * also handles Voltage comparison between DPMUs
             * */

            ret = connect_shared_bus();

            if(true == ret)
            {
                /* the other DPMU is connected to shared bus
                 * turn ON QSHARE (GLOAD_3)
                 * */
                cli_switches(IPC_SWITCHES_QSB, SW_ON);

                /* next state -> shared bus reconnected */
                state = shared_bus_reconnected;
            } else
            {   /* we could not connect with other DPMU
                 * check for wrong DPMU type was made in state no_short_circuit
                 * */

                /* next state -> shared bus not reconnected */
                state = shared_bus_not_reconnected;
            }
        }
        break;
    case shared_bus_reconnected:
        if(!timer_started)
        {
            time_start = timer_get_ticks() & 0x7fffffff;
            timer_started = true;
        }

        /* wait and see if error reappears */
        if(short_circuit_flag_set())
        {   /* continue without shared bus / other DPMU */
            /* Turn OFF QSHARE (GLOAD_3) */
            cli_switches(IPC_SWITCHES_QSB, SW_OFF);

            /* disconnect the other/others DPMU/s, Qsb */
            disconnect_other_dpmu_from_shared_bus();

            /* next state -> shared bus not reconnected */
            state = shared_bus_not_reconnected;

            break;
        } else
        {
            /* ms ticks, enough with 127 ms */
            elapsed_time = (timer_get_ticks() & 0x7fff) - time_start;
            //TODO - Time does not handle wrap around

            /* check timeout */
            if(2 < elapsed_time)
            {   /* problem resolved */
                /* next state -> clear error */
                state = clear_error;

                break;
            }
        }
        break;
    case shared_bus_not_reconnected:
        //TODO Mark as for continuing with reduced effect
        //     Probably as signal to CPU2 to change some parameter
//        sharedVars_cpu1toCpu2.available_power_budget_dc_input = xxx;

        canopen_emcy_send_power_sharing_error(1);

        /* mark handled */
        global_error_code_handled |= (1UL << ERROR_BUS_SHORT_CIRCUIT);

        /* next state -> wait for error to disappear */
        state = clear_error;
        break;
    case clear_error:
        /* problem resolved */
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_BUS_SHORT_CIRCUIT))
            canopen_emcy_send_dcbus_short_curcuit(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_BUS_SHORT_CIRCUIT);
        global_error_code_handled &= ~(1UL << ERROR_BUS_SHORT_CIRCUIT);

        /* clear the timer */
        timer_started = false;

        /* next state -> no short circuit */
        state = no_short_circuit;
        break;
    case wait_for_error_to_disappear:
        /* there is nothing more we can do
         * let IOP decide next step
         * */

        if(!short_circuit_flag_set())
        {   /* problem resolved */
            /* next state -> clear error */
            state = clear_error;
        }
        break;
    default:
        break;
    }
}

/* brief: check if Current output to load is above max
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_load_overcurrent(void)
{
    if(global_error_code & (1UL << ERROR_LOAD_OVER_CURRENT))
    {
        if(!(global_error_code_handled & (1UL << ERROR_LOAD_OVER_CURRENT)))
        {
            /* disconnect all switches
             * turn off regulation */
            IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

            /* mark handled */
            global_error_code_handled |= (1UL << ERROR_LOAD_OVER_CURRENT);

            /* send EMCY - send it once */
            canopen_emcy_send_load_overcurrent(1);

            /* mark it sent */
            global_error_code_sent    |= (1UL << ERROR_LOAD_OVER_CURRENT);
            global_error_code_handled |= (1UL << ERROR_LOAD_OVER_CURRENT);
        } else
        {
            ;
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1 << ERROR_LOAD_OVER_CURRENT))
            canopen_emcy_send_load_overcurrent(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_LOAD_OVER_CURRENT);
        global_error_code_handled &= ~(1UL << ERROR_LOAD_OVER_CURRENT);
    }
}

/* brief: check if temperatures are above thresholds
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: EMCY messages are handled in
 *       temperature_sensor_read_all_temperatures()
 *       non-blocking
 *
 * presumptions:
 *
 */
static void error_system_temperature(void)
{
    static bool timer_started = false;
    static uint32_t time_start;

    /* !!! This is handled in temperature_sensor_read_all_temperatures() !!! */
    if(global_error_code & (1UL << ERROR_OVER_TEMPERATURE))
    {
        /* According to specification:
         * Only inform IOP (done in temperature_sensor_read_all_temperatures())
         * Do not do anything more
         * IOP takes decision on what to do next
         * */
        if(!(global_error_code_handled & (1UL << ERROR_OVER_TEMPERATURE)))
        {
            if(!timer_started)
            {
                time_start = timer_get_ticks() & 0x7fffffff;
                timer_started = true;
            }

            /* ms ticks, enough with 127 ms */
            int16_t elapsed_time = (timer_get_ticks() & 0x7fff) - time_start;
            //TODO - Time does not handle wrap around

            //TODO What about timing
            /* check timeout */
            if(2 < elapsed_time)
            {
//                static bool message_sent = false;

                /* disconnect all switches
                 * turn off regulation */
                IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                global_error_code_handled |= (1UL << ERROR_OVER_TEMPERATURE);

                /* clear the timer */
                timer_started = false;
            }
        } else
        {
            ;
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* mark as unhandled - nothing need to be done  */
        global_error_code_handled &= ~(1UL << ERROR_OVER_TEMPERATURE);
    }
}

/* brief: check if there are any internal operational errors
 *
 * details: checks error flag
 *          signal IOP with EMCY
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: e.g. I2C communication error
 *       non-blocking
 *
 * presumptions:
 *
 */
static void error_operational(void)
{
    if(global_error_code & (1UL << ERROR_OPERATIONAL))
    {
        if(!(global_error_code_handled & (1UL << ERROR_OPERATIONAL)))
        {
            bool error_persist = false;

            /* test error */
            //TODO Test if error persist

            if(error_persist)
            {
                /* disconnect all switches
                 * turn off regulation */
                IPC_setFlagLtoR(IPC_CPU1_L_CPU2_R, IPC_CPU1_REQUIERS_EMERGECY_SHUT_DOWN);

                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_OPERATIONAL);

                /* send EMCY
                 * can change argument to any meaningful code != '0'
                 * */
                canopen_emcy_send_operational_error(1);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_OPERATIONAL);
            }
        } else
        {
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_OPERATIONAL))
            canopen_emcy_send_operational_error(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_OPERATIONAL);
        global_error_code_handled &= ~(1UL << ERROR_OPERATIONAL);
    }
}

/* brief: check if there are external power failures
 *
 * details: checks error flags
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *          one power line failure
 *          two power line failures
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_power_line_failure(void)
{
    if(global_error_code & (1UL << ERROR_EXT_PWR_LOSS))
    {
        if(!(global_error_code_handled & (1UL << ERROR_EXT_PWR_LOSS)))
        {
            /* send EMCY - send it once */
            canopen_emcy_send_power_line_failure(1);

            /* mark it sent */
            global_error_code_sent |= (1UL << ERROR_EXT_PWR_LOSS);

            //TODO Mark as for continuing with reduced effect
            //     Probably as signal to CPU2 to change some parameter
//            sharedVars_cpu1toCpu2.available_power_budget_dc_input = xxx;

            /* mark handled */
            global_error_code_handled |= (1UL << ERROR_EXT_PWR_LOSS);
        } else
        {
            /* there is nothing more we can do
             * let IOP decide next step
             * till then, continue as normal, but with reduced effect
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_EXT_PWR_LOSS))
            canopen_emcy_send_power_line_failure(0);

        global_error_code_sent    &= ~(1UL << ERROR_EXT_PWR_LOSS);
        global_error_code_handled &= ~(1UL << ERROR_EXT_PWR_LOSS);
    }

    if(global_error_code & (1UL << ERROR_EXT_PWR_LOSS_BOTH))
    {
        if(!(global_error_code_handled & (1UL << ERROR_EXT_PWR_LOSS_BOTH)))
        {
            /* send EMCY - send it once */
            canopen_emcy_send_power_line_failure_both(1);

            /* mark it sent */
            global_error_code_sent |= (1UL << ERROR_EXT_PWR_LOSS_BOTH);

            //TODO Mark as for allowing safe parking
            //     Probably as signal to CPU2 to disrespect Minimum SoC
//            sharedVars_cpu1toCpu2.safe_parking_allowed = 1;
//            sharedVars_cpu1toCpu2.min_allowed_state_of_charge_of_energy_bank = 0;

            /* mark handled */
            global_error_code_handled |= (1UL << ERROR_EXT_PWR_LOSS_BOTH);
        } else
        {
            ;
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_EXT_PWR_LOSS_BOTH))
            canopen_emcy_send_power_line_failure_both(0);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_EXT_PWR_LOSS_BOTH);
        global_error_code_handled &= ~(1UL << ERROR_EXT_PWR_LOSS_BOTH);
    }
}

/* brief: check State of Charge error
 *
 * details: checks error flag
 *          turns off switches and DCDC
 *          signal IOP with EMCY
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_state_of_charge(void)
{
    /* ERROR_SOC_BELOW_SAFETY_THRESHOLD
     * not enough energy for safe parking
     * */
    if(global_error_code & (1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD))
    {
        if(!(global_error_code_handled & (1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD)))
        {
            bool error_persist = false;

            /* test error */
            /*TODO Test if error persist
             * in the meaning or inaccuracy of measurement
             * send if enough measurements/mean value is giving this error */

            if(error_persist)
            {
                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD);

                /* send EMCY */
                canopen_emcy_send_state_of_charge_safety_error(1, sharedVars_cpu2toCpu1.remaining_energy_to_min_soc_energy_bank);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD);
            }
        } else
        {
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD))
            canopen_emcy_send_state_of_charge_safety_error(0, sharedVars_cpu2toCpu1.soc_energy_bank);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD);
        global_error_code_handled &= ~(1UL << ERROR_SOC_BELOW_SAFETY_THRESHOLD);
    }

    /* ERROR_SOC_BELOW_LIMIT
     * not enough Voltage for boosting to S_TARGET_VOLTAGE_AT_DC_BUS
     * */
    if(global_error_code & (1UL << ERROR_SOC_BELOW_LIMIT))
    {
        if(!(global_error_code_handled & (1UL << ERROR_SOC_BELOW_LIMIT)))
        {
            bool error_persist = false;

            /* test error */
            //TODO Test if error persist
            //TODO in the meaning or inaccuracy of measurement
            //TODO send if enough measurements/mean value is giving this error

            if(error_persist)
            {
                /* mark handled */
                global_error_code_handled |= (1UL << ERROR_SOC_BELOW_LIMIT);

                /* send EMCY */
                //TODO change to Voltage over energy bank
                canopen_emcy_send_state_of_charge_min_error(1, sharedVars_cpu2toCpu1.soc_energy_bank);

                /* mark it sent */
                global_error_code_sent |= (1UL << ERROR_SOC_BELOW_LIMIT);
            }
        } else
        {
            /* there is nothing more we can do
             * let IOP decide next step
             * */
        }
    } else
    {
        /* send EMCY CLEAR - send it once */
        if(global_error_code_sent & (1UL << ERROR_SOC_BELOW_LIMIT))
            canopen_emcy_send_state_of_charge_min_error(0, sharedVars_cpu2toCpu1.soc_energy_bank);

        /* mark as unhandled - nothing need to be done  */
        global_error_code_sent    &= ~(1UL << ERROR_SOC_BELOW_LIMIT);
        global_error_code_handled &= ~(1UL << ERROR_SOC_BELOW_LIMIT);
    }
}

/* brief: check if there are any errors
 *        if not, send EMCY OK
 *
 * details: make sure all previous errors have got their EMCY error clear
 *          messages sent before sending EMCY OK.
 *          We do this by checking 'global_error_code_sent'.
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: non-blocking
 *
 * presumptions:
 *
 */
static void error_no_error(void)
{
    static bool message_sent = false;

    if((0 == (global_error_code & (~(1UL << ERROR_NO_ERRORS)) )) &&
       (0 == global_error_code_handled) &&
       (0 == global_error_code_sent))
    {
        /* send EMCY OK - send it once */
        if(!message_sent)
        {
            canopen_emcy_send_no_errors();
            message_sent = true;
        }
    } else
    {
        message_sent = false;
    }
}

static void error_copy_error_codes_from_CPU2()
{
    global_error_code |= sharedVars_cpu2toCpu1.error_code;
}

/* brief: call static functions to check if there are errors to signal
 *        and handle
 *
 * details:
 *
 * requirements:
 *
 * argument: none
 *
 * return: none
 *
 * note: some of the errors might have been signaled and handle elsewhere,
 *       e.g. temperature error/warning
 *       non-blocking
 *
 * presumptions:
 *
 */
void error_check_for_errors(void)
{
    static bool test_update_of_error_codes = false;
//    if(test_update_of_error_codes)
//    {
        uint32_t code = 0;
        global_error_code = code;
//        test_update_of_error_codes = false;

    error_copy_error_codes_from_CPU2();

    error_dcbus_over_voltage();

    error_dcbus_under_voltage();

    error_dcbus_short_circuit();

    error_load_overcurrent();

    error_system_temperature();

    error_operational();

    error_power_line_failure();

    error_state_of_charge();

    error_no_error();
//    }
}
