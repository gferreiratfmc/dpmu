/*
 * serial.cpp
 *
 *  Created on: 30 mars 2022
 *      Author: us
 */

#include <stdarg.h>
#include <stdio.h>
#include <stdbool.h>
#include <inc/hw_sci.h>

#include "driverlib.h"
#include "device.h"
#include "board.h"
#include "hal.h"
#include "serial.h"


/**
 * The following info comes from board.h which depends on dpmu_cpu1.syscfg
 * and is generated by the SysConfig tool.
 */
const struct SerialSettings cli_serial_settings = {
    //
    .interruptNumberRx = INT_cli_serial_RX,
    .interruptAckGroupRx = INT_cli_serial_RX_INTERRUPT_ACK_GROUP,
    .interruptNumberTx = INT_cli_serial_TX,
    .interruptAckGroupTx = INT_cli_serial_TX_INTERRUPT_ACK_GROUP,
    .sciBase = cli_serial_BASE,
    .baudrate = cli_serial_BAUDRATE,
    .lspclk = DEVICE_LSPCLK_FREQ,
    .cfg = cli_serial_CONFIG_WLEN | cli_serial_CONFIG_STOP | cli_serial_CONFIG_PAR   //
};

int debug_level = DEBUG_ERROR;

static int Serial_try_putchar(struct Serial *dev, char ch)
{
    bool avail;
//    unsigned int fifo_len = (dev->tx_fifo_in - dev->tx_fifo_out);

    avail = dev->tx_fifo_len < FIFO_BUFSIZE;

    if (avail) {
        dev->tx_buf[dev->tx_fifo_in++] = ch;
        dev->tx_fifo_in &= FIFO_MASK;
        dev->tx_fifo_len++;
        uint16_t val = __disable_interrupts();
        if (!dev->tx_active) {
            SCI_enableInterrupt(dev->_settings->sciBase, SCI_INT_TXRDY);
            SCI_writeCharNonBlocking(dev->_settings->sciBase, dev->tx_buf[dev->tx_fifo_out++]);
            dev->tx_fifo_out &= FIFO_MASK;
            dev->tx_fifo_len--;
            dev->tx_active = true;
        }

        if (!(val & 1)) {
            __enable_interrupts();
        }
    }

    if (avail) {
        return 1;
    } else {
        return 0;
    }
}

static int Serial_putchar(struct Serial *dev, char ch)
{
    while (!Serial_try_putchar(dev, ch));

    return 1;
}

static bool Serial_recv_ready(struct Serial *dev)
{
    return dev->rx_fifo_len > 0;
}

void Serial_ctor(struct Serial *dev)
{
    dev->_settings = &cli_serial_settings;

    dev->tx_fifo_in = 0;
    dev->tx_fifo_out = 0;
    dev->tx_fifo_len = 0;

    dev->rx_fifo_in = 0;
    dev->rx_fifo_out = 0;
    dev->rx_fifo_len = 0;

    dev->tx_active = false;

    dev->_open = false;
}

bool Serial_is_open(struct Serial *dev)
{
    return dev->_open;
}

bool Serial_open(struct Serial *dev)
{
    if (dev->_open)
        return false;

    dev->tx_fifo_in = 0;
    dev->tx_fifo_out = 0;
    dev->tx_fifo_len = 0;

    dev->rx_fifo_in = 0;
    dev->rx_fifo_out = 0;
    dev->rx_fifo_len = 0;

    dev->tx_active = false;

    dev->_open = true;

    /* set HW SCI module into freerun mode
     * HW does not stop during a debug halt
     */
    HWREG(dev->_settings->sciBase + SCI_O_PRI) = SCI_PRI_FREESOFT_M;

#if 0
    EALLOW;

//    SCI_setConfig(_settings.sciBase, _settings.lspclk, _settings.baudrate,
//            _settings.cfg);
//    SCI_performSoftwareReset(_settings.sciBase);
//    SCI_enableInterrupt(_settings.sciBase, SCI_INT_RXRDY_BRKDT);

//    SCI_disableModule(_settings.sciBase);
    SCI_clearInterruptStatus(_settings.sciBase, SCI_INT_RXFF | SCI_INT_TXFF | SCI_INT_FE | SCI_INT_OE | SCI_INT_PE | SCI_INT_RXERR | SCI_INT_RXRDY_BRKDT | SCI_INT_TXRDY);
    SCI_clearOverflowStatus(_settings.sciBase);

    SCI_disableFIFO(_settings.sciBase);
    SCI_resetChannels(_settings.sciBase);

    SCI_setConfig(_settings.sciBase, DEVICE_LSPCLK_FREQ, mySCIA_BAUDRATE, (SCI_CONFIG_WLEN_8|SCI_CONFIG_STOP_ONE|SCI_CONFIG_PAR_NONE));
    SCI_disableLoopback(_settings.sciBase);
    SCI_performSoftwareReset(_settings.sciBase);
    SCI_enableInterrupt(_settings.sciBase, SCI_INT_RXRDY_BRKDT);
    SCI_enableInterrupt(_settings.sciBase, SCI_INT_FE | SCI_INT_OE | SCI_INT_PE | SCI_INT_RXERR);
    SCI_enableModule(_settings.sciBase);

    EDIS;
#endif

    return true;
}

void Serial_close(struct Serial *dev)
{
    dev->_open = false;
    SCI_disableInterrupt(dev->_settings->sciBase, SCI_INT_RXRDY_BRKDT);
    SCI_disableInterrupt(dev->_settings->sciBase, SCI_INT_FE | SCI_INT_OE | SCI_INT_PE | SCI_INT_RXERR);
    SCI_disableInterrupt(dev->_settings->sciBase, SCI_INT_TXRDY);
    dev->tx_active = false;
}

int Serial_write(struct Serial *dev, const char *buf, int count)
{
#if 0
    unsigned int fifo_len = FIFO_BUFSIZE - (dev->tx_fifo_in - dev->tx_fifo_out);

    if (fifo_len < count) {
        count = fifo_len;
    }

    if (count > 0) {
        for (int i = 0; i < count; i++) {
            dev->tx_buf[dev->tx_fifo_in++] = *buf++;
            dev->tx_fifo_in &= FIFO_MASK;
        }

        uint16_t val = __disable_interrupts();

        if (!dev->tx_active) {
            SCI_enableInterrupt(dev->_settings->sciBase, SCI_INT_TXRDY);
            SCI_writeCharNonBlocking(dev->_settings->sciBase, dev->tx_buf[dev->tx_fifo_out++]);
            dev->tx_fifo_out &= FIFO_MASK;
            dev->tx_active = true;
        }

        if (!(val & 1)) {
            __enable_interrupts();
        }
    }
#endif

    for (int i = 0; i < count; ++i)
        Serial_putchar(dev, *buf++);

    return count;
}

int Serial_read(struct Serial *dev, char *buf, int count)
{
    uint16_t val = __disable_interrupts();

    unsigned int fifo_len = (dev->rx_fifo_in - dev->rx_fifo_out);

    if (dev->rx_fifo_len < count) {
        count = dev->rx_fifo_len;
    }

    for (int i = 0; i < count; i++) {
        *buf++ = dev->rx_buf[dev->rx_fifo_out++];
        dev->rx_fifo_out &= FIFO_MASK;
    }

    dev->rx_fifo_len -= count;

    if (!(val & 1)) {
        __enable_interrupts();
    }

    return count;
}

int Serial_getchar(struct Serial *dev)
{
    int res = -1;

    if (Serial_recv_ready(dev)) {
        char c;
        Serial_read(dev, &c, 1);
        res = c;
    }

    return res;
}

int Serial_printf(struct Serial *dev, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    int n = vsprintf(dev->pbuf, fmt, args);
    va_end(args);

//    if (SCI_getInterruptStatus(dev->_settings->sciBase) & (SCI_INT_FE | SCI_INT_OE | SCI_INT_PE | SCI_INT_RXERR)) {
//        SCI_performSoftwareReset(dev->_settings->sciBase);
//    }
//    if (SCI_getRxStatus(dev->_settings->sciBase) & SCI_INT_RXRDY_BRKDT) {
        if (n > 0) {
            int k = 0;
            while (k < n) {
////                uint16_t a = SCI_getInterruptStatus(dev->_settings->sciBase);
////                a = HWREG(dev->_settings->sciBase + SCI_O_RXST);
//////                SCI_resetChannels(dev->_settings->sciBase);
////                if (a & SCI_RXST_BRKDT){//SCI_INT_RXRDY_BRKDT) {
//                if (!(SCI_getInterruptStatus(dev->_settings->sciBase) & SCI_INT_RXRDY_BRKDT)) {
////                    SCI_clearInterruptStatus(dev->_settings->sciBase, SCI_INT_RXRDY_BRKDT);
//                    SCI_performSoftwareReset(dev->_settings->sciBase);
////                    SCI_resetRxFIFO(dev->_settings->sciBase);
////                    SCI_resetTxFIFO(dev->_settings->sciBase);
//                    break;
//                }
//                else {
                    k += Serial_try_putchar(dev, dev->pbuf[k]);
//                }
    //            k += Serial_write(dev, dev->pbuf + k, n - k);
            }
        }
//    }

    return n;
}

int Serial_debug(uint16_t debugLevel, struct Serial *dev, const char *fmt, ...)
{
    uint16_t status = true;
//    char string[PRINTBUFSIZE];

    if(debugLevel <= debug_level)
    {
//        va_list args;
//        va_start(args, fmt);
//        vsprintf(string, fmt, args);
//        va_end(args);
//        status = Serial_printf(dev, string);
        va_list args;

        va_start(args, fmt);
        int n = vsprintf(dev->pbuf, fmt, args);
        va_end(args);

        if (n > 0) {
            int k = 0;
            while (k < n) {
                k += Serial_try_putchar(dev, dev->pbuf[k]);
//                k += Serial_write(dev, dev->pbuf + k, n - k);
            }
        }
    } else
    {
        status = false;
    }

    return status;
}

void Serial_set_debug_level(int requested_debug_level)
{
    debug_level = requested_debug_level;
}

void Serial_rx_isr(struct Serial *dev)
{
    if (SCI_getInterruptStatus(dev->_settings->sciBase) & (SCI_INT_FE | SCI_INT_OE | SCI_INT_PE | SCI_INT_RXERR)) {
        SCI_performSoftwareReset(dev->_settings->sciBase);
    }
    if (SCI_getInterruptStatus(dev->_settings->sciBase) & SCI_INT_RXRDY_BRKDT) {
        if (dev->rx_fifo_len < FIFO_BUFSIZE) {
            char c = SCI_readCharNonBlocking(dev->_settings->sciBase);
            dev->rx_buf[dev->rx_fifo_in++] = c;
            dev->rx_fifo_in &= FIFO_MASK;
            dev->rx_fifo_len++;
            if (c == 0x7e || (dev->rx_fifo_in - dev->rx_fifo_out) >= FIFO_MASK >> 1) { }
        }
    }

    HAL_Interrupt_clearPIE(dev->_settings->interruptAckGroupRx);
}

void Serial_tx_isr(struct Serial *dev)
{
    if (SCI_getInterruptStatus(dev->_settings->sciBase) & SCI_INT_TXRDY) {
        if (dev->tx_fifo_len > 0) {
            SCI_writeCharNonBlocking(dev->_settings->sciBase, dev->tx_buf[dev->tx_fifo_out++]);
            dev->tx_fifo_out &= FIFO_MASK;
            dev->tx_fifo_len--;
        } else {
            SCI_disableInterrupt(dev->_settings->sciBase, SCI_INT_TXRDY);
            dev->tx_active = false;
        }
    }

    //SciaRegs.SCIFFTX.bit.TXFFINTCLR=1;   // Clear SCI Interrupt flag
//            SCI_clearInterruptStatus(dev->_settings->sciBase, SCI_INT_TXRDY);
    HAL_Interrupt_clearPIE(dev->_settings->interruptAckGroupTx);
}
